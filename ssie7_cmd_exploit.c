#include "ssie7.h"


//------------------------------------------------------------------------------
int cmd_ssie7_status( T_WORK *t_work )

// AFFICHE LE STATUS DU SERVEUR SSIE v7
//------------------------------------------------------------------------------
	{
	r = cmd_status( t_work );	// Commande standard status (voir dans ssie7lib_cmd_exploit.c)
	
	// STATUS DE MFT SI INSTALLE EN LOCAL
	
	if ( mft_exists() )
		{
		strdcpy( &cmd, mft_exe(), " status", _ );
		System( &s, cmd );
		print( s, BR, _ );
		}
	
	return r;
	}




#ifdef OS_WINDOWS
//------------------------------------------------------------------------------
int cmd_ssie7_ask_start( T_WORK *t_work )

// DEMANDE LE DEMARRAGE DE SSIE (WINDOWS UNIQUEMENT)
//------------------------------------------------------------------------------
	{
	// DEMARRE LE SERVICE WINDOWS SSIE
	
	system( "net start SSIE" );
	
	return OK;
	}


//------------------------------------------------------------------------------
int cmd_ssie7_ask_stop( T_WORK *t_work )

// DEMANDE L'ARRET DE SSIE (WINDOWS UNIQUEMENT)
//------------------------------------------------------------------------------
	{
	// ARRETE LE SERVICE WINDOWS SSIE
	
	system( "net stop SSIE" );
	
	return OK;
	}
#endif


char *nat_search();

//------------------------------------------------------------------------------
int cmd_ssie7_start( T_WORK *t_work )

// DEMARRAGE DE SSIE7
//------------------------------------------------------------------------------
	{
	if (( ! is_authorized( "is_admin", null ) )
		#ifdef OS_UNIX
		||( strcmp( user, ssie_user ) )
		||( strcmp( sysuser(), ssie_user ) )
		#endif
		)
		{
		print( "ERREUR : Vous n'êtes pas habilité pour réaliser cette action", _ );
		return ERROR;
		}

	
//	strdcpy( &fname, dirwrk, DIR_CHAR "gateway_*.pid", _ );
//	file_delete( fname );
	
	#ifdef OS_WINDOWS

	strdcpy( &fname, "d:/r2000/mft/pam2000.exe", _ );
	if ( file_exists( fname ) )
		{
		var_free( h );
		h = var_new();
		if ( v = getenv( "PAM2000_DIRBIN" ) )	var_set( h, "dirbin", v );
		if ( v = getenv( "PAM2000_DIRCONF" ) )	var_set( h, "dirconf", v );
		if ( v = getenv( "PAM2000_DIRDAT" ) )	var_set( h, "dirdat", v );
		if ( v = getenv( "PAM2000_DIRLOG" ) )	var_set( h, "dirlog", v );
		if ( v = getenv( "PAM2000_DIRTMP" ) )	var_set( h, "dirtmp", v );
		if ( v = getenv( "PAM2000_DIRWRK" ) )	var_set( h, "dirwrk", v );
		if ( v = getenv( "PAM2000_DIRRECV" ) )	var_set( h, "dirrecv", v );
		if ( v = getenv( "PAM2000_DIRSEND" ) )	var_set( h, "dirsend", v );
		strdcpy( &fname, "d:/r2000/mft/pam2000.dat", _ );
		var_save( h, fname );
		}

	#ifndef MODE_CONTROLEUR
	if ( process_count( "T0_SSIE.exe" ) == 0 )
		{	
		strdcpy( &cmd, dirbin, "\\T0_SSIE.exe", _ );
		StartH( cmd );
		}
	#endif
	
	#else // UNIX
	
	if ( ! is_sudo_conf_ok() )
		{
		print( "ATTENTION : sudo ssie7 non paramétré !!!" BR BR, _ );
		}

	#endif
	
	// MONTEE DE VERSION
/*	
	strdcpy( &fname, dirdat, DIR_CHAR "mftcat", _ );
	if ( ( dir_exists( dirsend ) )&&( ! dir_exists( fname ) ) )
		{
		mkdir( fname );
		
		print( "Indexation du catalogue. Merci de patienter ..." BR, _ );
		
		// CREATION DES INDEXS
		
		strdcpy( &fname, dirsend, DIR_CHAR "*.info", _ );
		tf= NULL;
		while( tf = file_list( tf, fname, "absdir nodir" ) )
			{
			strdcpy( &fname, tf->dir, DIR_CHAR, tf->name, _ );
			var_free( h );
			h = var_load( fname );
			strdcpy( &ida, substr( tf->name, 0, 8 ), _ );
			mft_save( t_work, h, "SEND", var_get( h, "rpart" ), null );
			}
		
		strdcpy( &fname, dirrecv, DIR_CHAR "*.info", _ );
		tf= NULL;
		while( tf = file_list( tf, fname, "absdir nodir" ) )
			{
			strdcpy( &fname, tf->dir, DIR_CHAR, tf->name, _ );
			var_free( h );
			h = var_load( fname );
			strdcpy( &ida, substr( tf->name, 0, 8 ), _ );
			mft_save( t_work, h, "RECV", var_get( h, "spart" ), null );
			}

		print( "Indexation du catalogue terminée." BR, _ );
		}
*/	
	
	// DEMARRAGE DE MFT
	
	if ( mft_exists( ) )
		{
		print( BR "mft start ..." BR, _ );
		strdcpy( &cmd, mft_exe(), " start", _ );
		system( cmd );
		}
	
	// DEMARAGE STANDARD DU SERVEUR SSIE (voir dans ssie7lib_cmd_exploit.c)
	
	mkdir( dirtemp );
	
	#ifdef OS_UNIX
	System( &s, "chmod 755 /appli/ssie7" );
	System( &s, "chmod 755 /appli/ssie7/data" );
	System( &s, "chmod 777 /appli/ssie7/data/temp" );
	//Ticket#2017080110000826: ajout de droit au /tmp
	System( &s, "chmod 770 /appli/ssie7/data/wrk/tmp" );
	#endif

	
	if ( cmd_start( t_work ) == ERROR ) return ERROR;

	strdcpy( &fname, dirwrk, DIR_CHAR "ssie7_is_started", _ );
	file_save_str( fname, "", 0 );
	
	
	// CREE LE FICHIER "VIDE.TXT" UTILISE LORS DE L'ENVOI DE MESSAGES.
	
    v = str( dirwrk, DIR_CHAR "vide.txt", _ );
	file_save_str( v, "", 0 );


	// RECHARGE LA CONFIG DU PARTENAIRE "MFTCCWEX".
		
	strdcpy( &fname, dirconf, DIR_CHAR "part" DIR_CHAR, "MFTCCWEX.dat", _ );
	if ( !file_exists( fname ) )
	    {
	    b = false;
		v = var_get( hSrvConf, "part_auto_crea" );
		if ( !strcmp( v, "Oui" ) )
			{
			// RECHERCHE LE PARTENAIRE SUR LE SERVEUR D'ANNUAIRE
			strdcpy( &cmd, argv[0], " part MFTCCWEX loadnat", _ );
			System( &s, cmd );
			b = file_exists( fname );
			}
		if (  !b )
			{
			error_set( 1, "ERREUR : Le partenaire MFTCCWEX est inconnu.", _ );
			hCnx = hCnxOld;
			return ERROR;
			}

		}

		
	// DEMARRAGE DE LA PASSERELLE SYNCHRONE SI BESOIN
	
	if (( !mft_exists( ) )&&( v = var_get( hSrvConf, "ancien_mft" ) )
			&&( !stricmp( v, "Oui" ) )
		) // Si ancien_mft == "Oui" ==> c'est une montée de version
		{
		strdcpy( &fname, dirwrk, DIR_CHAR "gateway_1761_.mft", _ );
		strdcpy( &fname1, dirwrk, DIR_CHAR "no_gateway.mft", _ );

		if ( ( !file_exists( fname1 ) )
			&&( ( !file_exists( fname ) )
				||( ( time(NULL) - file_date( fname ) ) < ( 60*60*24*31*6 /*6 mois maxi*/) ) )
			)
			{
			// FICHIER DATE DE MOINS DE 6 MOIS	
			partname = var_get( hSrvConf, "mft_gateway" );
			if (( !partname )||( !(partname[0]) ))
				{
				strdcpy( &cmd, argv[0], " gateway run 1761 '' si-ssie.edf.fr", _ );
				}
			else
				{
				if ( !part_exists( t_work ) )
					{
					logw( "MFT GATEWAY : ERREUR : Le partenaire ", partname, " est inconnu.", _ );
					print( "MFT GATEWAY : ERREUR : Le partenaire ", partname, " est inconnu.", _ );
					return ERROR;
					}
				hPart = var_load( fname );
				if ( ! ( v1 = var_get( hPart, "dns_ssie" ) ) )
					if ( ! ( v1 = var_get( hPart, "ip_ssie" ) ) )
						{
						logw( "MFT GATEWAY : ERREUR : Le partenaire ", partname, " est mal configuré.", _ );
						print( "MFT GATEWAY : ERREUR : Le partenaire ", partname, " est mal configuré.", _ );
						return ERROR;
						}
				
/*
				if ( ! ( v2 = var_get( hPart, "port" ) ) )
					{
					logw( "MFT GATEWAY : ERREUR : Le partenaire ", partname, " est mal configuré.", _ );
					print( "MFT GATEWAY : ERREUR : Le partenaire ", partname, " est mal configuré.", _ );
					return ERROR;
					}
*/
				
				strdcpy( &cmd, argv[0], " gateway run 1761 '' ", v1, _ );
				var_free( hPart );
				hPart = 0;
				}
			
			strdcpy( &fname, dirwrk, DIR_CHAR "cmd_gateway_1761.mft", _ );
			file_save_str( fname, cmd, -1 );
			StartH( cmd );
			}
		}
	

	// DEMARRAGE DES PASSERELLES SYNCHRONES SUPPLEMENTAIRES
	
	for( i = 0 ; v = var_getn( hSrvConf, i, &vn ) ; i++ )
		{
		if ( strnicmp( vn, "gateway_", 8 ) ) continue;
		
		strdcpy( &cmd, argv[0], " gateway run ", v1 = substr( vn, 8, -1 ), " ", v, _ );
		strdcpy( &fname, dirwrk, DIR_CHAR "cmd_gateway_", v1, ".mft", _ );
		file_save_str( fname, cmd, -1 );
		while( (pid = StartH( cmd )) == -1 ) Sleep(100);
		strdcpy( &fname, dirwrk, DIR_CHAR, module_name, "_gateway_", v1, ".pid", _ );
		file_save_str( fname, itoa( pid ), -1 );
		}
	
	return OK;
	}




//------------------------------------------------------------------------------
int cmd_ssie7_stop( T_WORK *t_work )

// ARRET DE SSIE7
//------------------------------------------------------------------------------
	{
	if (( ! is_authorized( "is_admin", null ) )
		#ifdef OS_UNIX
		||( strcmp( sysuser(), ssie_user ) )
		#endif
		)
		{
		print( "ERREUR : Vous n'êtes pas habilité pour réaliser cette action", _ );
		return ERROR;
		}

	
	// ARRET DU SERVEUR SSIE7
	
	cmd_stop( t_work );
	strdcpy( &fname, dirwrk, DIR_CHAR "ssie7_is_started", _ );
	unlink( fname );
	
	
	// ARRET DE MFT
	
	if ( mft_exists( ) )
		{
		strdcpy( &cmd, mft_exe(), " stop", _ );
		system( cmd );
		}

	#ifdef OS_WINDOWS
	
	// ARRET DE SSIE V6
	
	process_kill_all( "T0_SSIE" );
	
	#endif
	}



























