#include "ssie7lib.h"


//  cmd_status , cmd_start , cmd_stop , cmd_log 


//------------------------------------------------------------------------------
int cmd_status( T_WORK *t_work )

// AFFICHE LE STATUS DU SERVEUR SSIE
//------------------------------------------------------------------------------
	{
	server_conf_load();

	strdcpy( &fname, dirwrk, DIR_CHAR, module_name, "_server_", var_get(hSrvConf,"port"), ".pid", _ );
	if ( s ) s[0] = 0;
	pid = atoi(file_load( &s, fname ));
	if ( ! process_is_alive( pid ) )
		{
		print( product_name, " est arrêté" BR, _ );
		return 1;
		}
	
	strdcpy( &fname, dirwrk, DIR_CHAR, module_name, "_server_", var_get(hSrvConf,"port"), ".status", _ );
	if ( s ) s[0] = 0;
	if ( ! file_exists( fname ) )
		{
		print( product_name, " est en cours de démarrage" BR, _ );
		return 2;
		}
	if ( s ) s[0] = 0;
	file_load( &s, fname );
	strd_replace( &s, "[product_name]", product_name );
	print( s, BR, _ );

	return OK;
	}



//------------------------------------------------------------------------------
int cmd_start( T_WORK *t_work )

// DEMARRAGE STANDARD DU SERVEUR SSIE
//------------------------------------------------------------------------------
	{
	if ( request_mode == MODE_TCP ) return;

//	file_delete( dirtmp );
	mkdir( dirtmp );
	mkdir( dirwrk );
	mkdir( dirlog );
	strdcpy( &s, dirdat, DIR_CHAR "mftcat", _ );
	mkdir( s );
	if ( dirrecv )	mkdir( dirrecv );

	putenv( "SSIE_IGNORE_SIGNAL=Oui" );
	

	// CHARGEMENT ET VERIFICATION DE LA CONFIGURATION DU SERVEUR
	
	server_conf_reload();
	
	if (( ! file_exists( server_conf_fname ) )
		||( !(v = var_get( hSrvConf, "partname" )) )
		||( ! (v[0]) )
		)
		{
		#ifndef IHM_LOCALE
		print( "ERREUR : Le serveur n'est pas configuré" BR, _ );
		return ERROR;
		#else
		strdcpy( &cmd, argv[0], " server", _ );
		system( cmd );
		server_conf_reload();
		if (( ! file_exists( server_conf_fname ) )
			||( !(v = var_get( hSrvConf, "partname" )) )
			||( ! (v[0]) )
			)
			{
			print( "ERREUR : Le serveur n'est pas configuré" BR, _ );
			return ERROR;
			}
		#endif
		}
	

	srv_port = var_get( hSrvConf, "port" );
	if (( !srv_port )||( !(srv_port[0]) )||( ! is_numeric(srv_port) )
		||( (p=atoi(srv_port)) <= 0 )||( p > 65535 ))
		{
		print( "ERREUR : Le n° de port n'a pas valide" BR, _ );
		return ERROR;
		}
		
	v = var_get( hSrvConf, "ssl_config_ok" );
	if ( !v )
		{
		print( "ERREUR : Le paramétrage SSL n'est pas correcte" BR, _ );
		return ERROR;
		}

	v = var_get( hSrvConf, "product_name" );
	v1 = var_get( hSrvConf, "srvnat_list" );
	if ( ( ( !v )||( strcmp( v, product_name ) ) )&&( ( !v1 )||( strcmp( v1, "none" ) ) ) )
		{
		strdcpy( &cmd, argv[0], " server", _ );
		System( &s, cmd );
		}
	
	
	
	// VERIFIE QUE LE SERVEUR N'EST PAS DEJA DEMARRE
	
	strdcpy( &fname, dirwrk, DIR_CHAR, module_name, "_server_", srv_port, ".pid", _ );
	if ( s ) s[0] = 0;
	pid = atoi(file_load( &s, fname ));
	if ( process_is_alive( pid ) )
		{
		print( "ATTENTION : Le serveur est déjà démarré." BR, _ );
		return ERROR;
		}
	file_delete( fname );

	
	#ifdef OS_AIX
	
	// Ne redémarre pas en moins de 15 secondes
	strdcpy( &fname, dirwrk, DIR_CHAR, module_name, "_server.stop", _ );
	if ( file_exists( fname ) )
		{
		n = file_date( fname );
		for( ; sysdate - n < 15 ; sleep(1) );
		file_delete( fname );
		}
	
	#endif

	
	strdcpy( &fname, dirtmp, DIR_CHAR "*", _ );
	file_delete( fname );
	
	strdcpy( &fname, dirwrk, DIR_CHAR, module_name, "*.pid", _ );
	file_delete( fname );
	
	strdcpy( &fname, dirwrk, DIR_CHAR "bd_lock", _ );
	file_delete( fname );
	
	strdcpy( &fname, dirwrk, DIR_CHAR "LockServer", _ );
	file_delete( fname );

	strdcpy( &fname, dirwrk, DIR_CHAR, module_name, "_server_", srv_port, ".status", _ );
	file_delete( fname ); // Ne plus modifier fname car utilisé dans la boucle qui suit.

	for( t = time(NULL) ; time(NULL)-t < (3*60) ; )
		{
		// DEMARRE LE SERVEUR
		
		strdcpy( &cmd, argv[0], " server ", srv_port, _ );
		while( (pid = StartH( cmd )) == -1 ) Sleep(100);
	
	
		// VERIFIE QUE LE SERVEUR DEMARRE CORRECTMENT
		
		for( n = 0, b = false ; ; n++ )
			{
			sleep( 1 );
			if ( s ) s[0] = 0;
			file_load( &s, fname );
			if ( stripos( s, "erreur", 0 ) >= 0 ) break;
			if ( stripos( s, "est démarré", 0 ) >= 0 ) break;
			if ( ! process_is_alive( pid ) ) break;
			if ( stripos( s, "On attend", 0 ) >= 0 )
				{
				if ( ! ( n % 30 ) )
					{
					strdcpy( &cmd, "netstat -nat | grep \":", srv_port, "\"", _ );
					system( cmd );
					print( BR BR, s, BR BR, _ );
					}
				}
			}
		
		if ( ( stripos( s, "erreur", 0 ) < 0 )&&( stripos( s, "est démarré", 0 ) < 0 ) )
			{
			if ( stripos( s, " n'est pas libre", 0 ) > 0 )
				{
				print( s, BR, _ );
				return ERROR;
				}
				
			print( s, BR, _ );
			strdcat( &s, BR, "ERREUR : le serveur ne démarre pas !!!", BR, _ );
			print( "ERREUR : le serveur ne démarre pas => on réessaye", BR, _ );
			strdcpy( &cmd, argv[0], " stop", _ );
			System( &s, cmd );
			continue;
			}
		print( s, BR, _ );
		break;
		}
	
	file_load( &s, fname );
	if ( stripos( s, "est démarré", 0 ) < 0 )
		{
		strdcpy( &cmd, argv[0], " stop", _ );
		system( cmd );
		return ERROR;
		}
	
	// DEMARRE LE ROBOT
	
	strdcpy( &cmd, argv[0], " robot", _ );
	StartH( cmd );
	
	return OK;
	}



//------------------------------------------------------------------------------
int cmd_stop( T_WORK *t_work )

// ARRET STANDARD DU SERVEUR SSIE
//------------------------------------------------------------------------------
	{
	if ( request_mode == MODE_TCP ) return ERROR;

	// EMPECHE TOUTE MODIFICATION BIGDATA
	
	strdcpy( &fname3, dirwrk, DIR_CHAR "bd_lock", _ );
	file_save_str( fname3, "", 0 );


	// ARRET PROPRE
	
	#ifdef OS_WINDOWS
	strdcpy( &s1, module_name, ".exe", _ );
	#else // UNIX
	strdcpy( &s1, module_name, " ", _ );
	#endif

	strdcpy( &fname, dirwrk, DIR_CHAR, module_name, "_server.stop", _ );
	for( ; ( fp = fopen( fname, "wb" ) ) == NULL ; Sleep(100) );
	fclose( fp );
	
	for( sleep(1), n = 0 ; ( n < 1 )&&( process_count( s1 ) > 1 ) ; n++, sleep(1) );
	
	
	// ARRET FORCE
	
	for( n = 0 ; ( n < 100 )&&( process_count( s1 ) > 1 ) ; n++ )
		{
		process_kill_all( s1 );
		Sleep(10);
		}
	
	
	// NETTOYAGE
	
	unlink( fname3 ); // Ré autorise les modifications bigdata
	
	strdcpy( &fname, dirwrk, DIR_CHAR, module_name, "_server_*.pid", _ );
	file_delete( fname );
/*
	strdcpy( &fname, dirwrk, DIR_CHAR, module_name, "_server_*.waiting", _ );
	file_delete( fname );
	strdcpy( &fname, dirwrk, DIR_CHAR, module_name, "_server_*.locked", _ );
	file_delete( fname );
*/
	strdcpy( &fname, dirwrk, DIR_CHAR, module_name, "_robot*.pid", _ );
	file_delete( fname );

	strdcpy( &fname, dirwrk, DIR_CHAR "LockServer", _ );
	file_delete( fname );

	
	// AFFICHAGE
	
	server_conf_load();
	strdcpy( &fname, dirwrk, DIR_CHAR, module_name, "_server_", var_get(hSrvConf,"port"), ".status", _ );
	file_save_str( fname, str(product_name, " est arrêté", _), -1 );
	print( product_name, " est arrêté" BR, _ );
	logw( "SERVEUR : Arrêt : OK", _ );
	
	return OK;
	}




//------------------------------------------------------------------------------
int cmd_log( T_WORK *t_work )

// AFFICHE LA LOG SSIE
//------------------------------------------------------------------------------
	{
	if ( v = var_getn( hReq, 1, &w ) )
		{
		if ( atoi( w ) < 0 )
			{
			n = time(NULL) + ( atoi(w) * 24*60*60 );
			v1 = itod( n, "AAAA_MM_JJ" );
			v = var_getn( hReq, 2, &w );
			if ( v ) v = w;
			}
		else
			{
			v = w;
			v1 = currdate( "AAAA_MM_JJ" );
			}
		}
	else
		{
		v1 = currdate( "AAAA_MM_JJ" );
		}
	
	strdcpy( &fname, dirlog, "/", module_name, "_", v1, ".log", _ );
	
	if ( request_mode != MODE_TCP )
		file_icat( null, fname, v, null );
	else
		{
		file_icat( &s, fname, v, null );
		print( s, _ );
		}
	

	return OK;
	}

























