#include "ssie7lib.h"



//  cmd_status , cmd_start , cmd_stop , cmd_log 


//------------------------------------------------------------------------------
int cmd_status( T_WORK *t_work )

// AFFICHE LE STATUS DU SERVEUR SSIE
//------------------------------------------------------------------------------
	{
	server_conf_load();

	strdcpy( &fname, dirwrk, DIR_CHAR, module_name, "_server_", var_get(hSrvConf,"port"), ".pid", _ );
	if ( s ) s[0] = 0;
	pid = atoi(file_load( &s, fname ));
	if ( ! process_is_alive( pid ) )
		{
		print( product_name, " est arrêté" BR, _ );
		return ERROR;
		}
	
	strdcpy( &fname, dirwrk, DIR_CHAR, module_name, "_server_", var_get(hSrvConf,"port"), ".status", _ );
	if ( s ) s[0] = 0;
	if ( ! file_exists( fname ) )
		{
		print( product_name, " est en cours de démarrage" BR, _ );
		return OK;
		}
	file_load( &s, fname );
	print( s, BR, _ );

	return OK;
	}



//------------------------------------------------------------------------------
int cmd_start( T_WORK *t_work )

// DEMARRAGE STANDARD DU SERVEUR SSIE
//------------------------------------------------------------------------------
	{
	if ( request_mode == MODE_TCP ) return;
	
	mkdir( dirtmp );
	mkdir( dirwrk );
	mkdir( dirlog );
	
//	if ( dirrecv )	mkdir( dirrecv );

	// CHARGEMENT ET VERIFICATION DE LA CONFIGURATION DU SERVEUR
	
	server_conf_reload();
	if ( ! file_exists( server_conf_fname ) )
		{
		print( "ERREUR : Le serveur n'est pas configuré", _ );
		return ERROR;
		}
	
	srv_port = var_get( hSrvConf, "port" );
	if ( !srv_port )
		{
		print( "ERREUR : Le port n'a pas été paramétré", _ );
		return ERROR;
		}
		
/*
	v = var_get( hSrvConf, "ssl_config_ok" );
	if ( !v )
		{
		print( "ERREUR : Le paramétrage SSL n'est pas correcte", _ );
		return ERROR;
		}
*/

	
	// VERIFIE QUE LE SERVEUR N'EST PAS DEJA DEMARRE
	
	strdcpy( &fname, dirwrk, DIR_CHAR, module_name, "_server_", srv_port, ".pid", _ );
	if ( s ) s[0] = 0;
	pid = atoi(file_load( &s, fname ));
	if ( process_is_alive( pid ) )
		{
		print( "ERREUR : Le serveur est déjà démarré", _ );
		logw( "start : ERREUR : Le serveur est déjà démarré", _ );
		return ERROR;
		}
	file_delete( fname );

	strdcpy( &fname, dirtmp, DIR_CHAR "*", _ );
	file_delete( fname );
	
	strdcpy( &fname, dirwrk, DIR_CHAR, module_name, "_server_", srv_port, ".status", _ );
	file_delete( fname );

	

	for( t = time(NULL) ; time(NULL)-t < (3*60) ; )
		{
		// DEMARRE LE SERVEUR
		
		strdcpy( &cmd, argv[0], " server ", srv_port, _ );
		pid = StartH( cmd );
	
	
		// VERIFIE QUE LE SERVEUR DEMARRE CORRECTMENT
		
		for( b = false ; ; )
			{
			Sleep( 50 );
			if ( s ) s[0] = 0;
			file_load( &s, fname );
			if ( stripos( s, "erreur", 0 ) >= 0 ) break;
			if ( stripos( s, "est démarré", 0 ) >= 0 ) break;
			if ( ! process_is_alive( pid ) ) break;
			if ( stripos( s, "On attend", 0 ) >= 0 )
				{
				if ( !b ) print( s, BR, _ );
				b = true;
				}
			}
		
		if ( ( stripos( s, "erreur", 0 ) < 0 )&&( stripos( s, "est démarré", 0 ) < 0 ) )
			{
			if ( stripos( s, " n'est pas libre", 0 ) > 0 )
				{
				print( s, BR, _ );
				wexit(1);
				}
				
			print( s, BR, _ );
			strdcat( &s, BR, "ERREUR : le serveur ne démarre pas !!!", BR, _ );
//			file_save_str( fname, s, -1 );
			print( "ERREUR : le serveur ne démarre pas => on réessaye", BR, _ );
			logw( "start : ERREUR : le serveur ne démarre pas => on réessaye", BR, _ );
			strdcpy( &cmd, argv[0], " stop", _ );
			system( cmd );
			continue;
			}
		print( s, BR, _ );
		logw( s, _ );
		break;
		}
	
	if ( time(NULL)-t >= (3*60) )
		{
		file_load( &s, fname );
		if ( stripos( s, "est démarré", 0 ) < 0 )
			{
			print( s, BR, _ );
			strdcpy( &cmd, argv[0], " stop", _ );
			system( cmd );
			wexit(1);
			}
		}
	
	// DEMARRE LE ROBOT
	
	strdcpy( &cmd, argv[0], " robot", _ );
	StartH( cmd );
	
	return OK;
	}



//------------------------------------------------------------------------------
int cmd_stop( T_WORK *t_work )

// ARRET STANDARD DU SERVEUR SSIE
//------------------------------------------------------------------------------
	{
	if ( request_mode == MODE_TCP ) return ERROR;
	
	#ifdef OS_WINDOWS
	strdcpy( &s, module_name, EXE, _ );
	process_kill_all( s );
	Sleep(10);
	process_kill_all( s );
	#else
	strdcpy( &s, module_name, " ", _ ); // Pour éviter de tuer aussi ssie7annu, ssie7c et autres.
	while( process_count( s ) > 1 )
		{
		process_kill_all( s );
		Sleep(10);
		}
	#endif
		
	strdcpy( &fname, dirwrk, DIR_CHAR, module_name, "_server_*.pid", _ );
	file_delete( fname );
	strdcpy( &fname, dirwrk, DIR_CHAR, module_name, "_server_*.waiting", _ );
	file_delete( fname );
	strdcpy( &fname, dirwrk, DIR_CHAR, module_name, "_server_*.locked", _ );
	file_delete( fname );
	
	server_conf_load();
	strdcpy( &fname, dirwrk, DIR_CHAR, module_name, "_server_", var_get(hSrvConf,"port"), ".status", _ );
	file_save_str( fname, str(product_name, " est arrêté", _), -1 );
	print( product_name, " est arrêté" BR, _ );
	logw( "stop : ", product_name, " est arrêté", _ );
	
	return OK;
	}




//------------------------------------------------------------------------------
int cmd_log( T_WORK *t_work )

// AFFICHE LA LOG SSIE
//------------------------------------------------------------------------------
	{
	var_delete( hReq, "user" );
	if ( v = var_getn( hReq, 1, &w ) )
		{
		if ( atoi( w ) < 0 )
			{
			n = time(NULL) + ( atoi(w) * 24*60*60 );
			v1 = itod( n, "AAAA_MM_JJ" );
			v = var_getn( hReq, 2, &w );
			if ( v ) v = w;
			}
		else
			{
			v = w;
			v1 = currdate( "AAAA_MM_JJ" );
			}
		}
	else
		{
		v1 = currdate( "AAAA_MM_JJ" );
		}
	
	strdcpy( &fname, dirlog, "/", module_name, "_", v1, ".log", _ );
	file_icat( null, fname, v, null );		

	return OK;
	}

























